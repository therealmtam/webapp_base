'use strict';

var moment = require('moment');
var util = require('util');
var _ = require('lodash');
var utilities = require('@moveinc/prosoft-utilities');
var formatters = utilities.formatters;

const logger = require('./logging/log');

/**
 * Used to ensure the right data type for correlation_id.
 * If it is not a string, change it to a set value.
 * @param {string} correlation_id - the id used to group log points together.
 * @return Validated correlation_id.
 */
var ValidateCorrelationId = function (correlation_id) {
    var correlation_id_to_use = 'INVALID_CORRELATION_ID';

    if (_.isString(correlation_id)) {
        correlation_id_to_use = correlation_id;
    }

    return correlation_id_to_use;
};

/**
 * Used to generate the base formatting for the method_details object
 * @param {string} method_name - The name of the method that the log point is being tracked in.
 *                               Format: [file].[method] || [method]
 * @param {string} log_point - The name of the log point being tracked.
 * @param {object} start_time - The strat time (moment).  If null, this is generated by this function.
 * @return {object} the method_details object.
 */

var GetMethodDetailsObject = function (method_name, log_point, start_time) {
    // determine if start_time was passed in
    var generate_start_time = start_time ? false : true;

    // ensure that start_time is set to the right format
    if (!moment.isMoment(start_time)) {
    // make sure it's a valid date string being passed
        if (_.isString(start_time) && start_time.match(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/)) {
            start_time = moment(start_time);
        }
        else {
            start_time = moment();
        }
    }

    // deafult the method_details object
    var method_details = {
        file: '',
        method_name: method_name || 'unspecified',
        log_point: log_point || 'unspecified',
        timing: {
            start_time: start_time.toISOString()
        }
    };

    // if a start_time was provided
    if (!generate_start_time) {
        var end_date = moment();
        // calculate the end time and the difference in run time
        method_details.timing.end_time = end_date.toISOString();
        method_details.timing.elapsed_time = end_date.diff(start_time);
    }

    // if there is a "." in the string that means a method name was passed through
    var name_values = method_details.method_name.split('.');
    if (name_values.length > 1) {
    // build the object values based on the array
        _.forEach(name_values, function (value, index) {
            // first value is the file name
            if (index === 0) {
                method_details.file = value;

            }
            // all other values are parts of the method_name
            else if (index === 1) {
                method_details.method_name = value;
            }
            // for parts beyond the first ".", restore the "."
            else {
                method_details.method_name += '.' + value;

            }
        });
    }
    // there is no file name
    else {
    // remove the file name from the returned object
        delete method_details.file;
    }

    return method_details;
};

/**
 * Used to format an error in a standard way.  Leverages the prosoft-utilities formatter
 * @param {object} err - An error to be formatted
 * @return {object} the formatted error.
 */
var FormatError = function (err) {
    // ensure that the error object is a vaid format
    if (!err || !_.isPlainObject(err)) {
        err = {};
    }

    // do the initial formatting using the prosoft-utilities formattter module
    var error = formatters.formatError(err);

    // ensure that there are errors returned
    if (error && _.isArray(error.errors) && error.errors.length === 1) {
    // check if only one value was returned and it contains a message
        if (error.errors[0].message && _.isString(error.errors[0].message)) {
            // pull the message out to the root
            error.message = error.errors[0].message;
            // if the only thing in the object in the errors array was the message
            if (Object.keys(error.errors[0]).length === 1) {
                // remove the array
                delete error.errors;
            }
        }
        // if there are no values in the errors array
        else if (Object.keys(error.errors[0]).length === 0) {
            // remove the array
            delete error.errors;
        }
    }

    return error;
};

/**
 * Used to log the methond name and method parameters to the debug log.
 * This level of debug logging is not required for most cases, so only
 * do the logging if the appropriate debug level is set, or the
 * force_debug flag is passed
 * @param {string} method_name - The methos for which the parameters are being logged.
 *                               Format: [file].[method] || [method]
 * @param {object} method_parameters - The parameters passed to the method
 * @param {string} correlation_id - the correlation id to be logged.
 * @param {string} log_level - the log_leve to use during logging.  If not passed it is set to debug.
 * @return {string} the determined start_time time (ISOString).
 */
var LogMethodDetail = function (method_name, method_parameters, correlation_id, log_level) {
    log_level = log_level || 'debug';
    // allow these logs to not be written for local debugging
    if (process.env.SUPRESS_TIMING !== 'true') {
    // create method details object
        var MethodDetails = module.exports._internalFunctions.getMethodDetailsObject(method_name, 'start of function call');

        if (method_parameters) {
            MethodDetails.method_parameters = method_parameters;
        }

        // allow these logs to be recorded debugPoint logs for local debugging
        if (process.env.TIMING_AS_DEBUGPOINT !== 'true') {
            // log method details object
            module.exports._internalFunctions.logPassthrough(log_level, MethodDetails, correlation_id);
        }
        else {
            module.exports.debugPoint(MethodDetails, 'Log Method Details');
        }
        // return the start_time
        return MethodDetails.timing.start_time;
    }
    return null;
};

/**
 * Used to log the methond name , log_point, timing informaiton, and possible additional
 * details in the logs.
 * The default log_level is debug.  This can be overriden by the caller, but if an error
 * is being logged the log level changes to error.  If not an error, but the timing details
 * indicates execution above 500ms then log level is changed to warn.
 * @param {string} method_name - The methos for which the parameters are being logged.
 *                               Format: [file].[method] || [method]
 * @param {object} log_point - The name of the log point to log.
 * @param {object} start_time - An ISOString containing the time that the last log point was run.
 *                              This value allows for the function to calculate an elapsed time.
 * @param {string} correlation_id - the correlation id to be logged.
 * @param {any} message - A value to log.
 * @param {string} message_type - The name of the element the message is assigned to in the log.
 * @param {string} log_level - the log_leve to use during logging.  If not passed it is set to debug.
 * @return {string} the determined start_time time (ISOString).
 */
var LogTiming = function (method_name, log_point, start_time, correlation_id, message, message_type, log_level) {
    log_level = log_level || 'debug';
    // allow these logs to not be written for local debugging
    if (process.env.SUPRESS_TIMING !== 'true') {
        start_time = start_time ? start_time : moment();
        var MethodDetails = module.exports._internalFunctions.getMethodDetailsObject(method_name, log_point, start_time);

        // add the relevan message to the object to log
        if (message) {
            if (!message_type) {
                message_type = 'error';
            }
            if (message_type === 'error') {
                log_level = 'error';
                message = module.exports._internalFunctions.formatError(message);
            }
            MethodDetails[message_type] = message;
        }

        // force the log to log as warn if the elapsed time is greater than 500 ms
        if (log_level !== 'error' && MethodDetails.timing.elapsed_time > 500) {
            log_level = 'warn';
        }

        // allow these logs to be recorded debugPoint logs for local debugging
        if (process.env.TIMING_AS_DEBUGPOINT !== 'true') {
            // log method details object
            module.exports._internalFunctions.logPassthrough(log_level, MethodDetails, correlation_id);
        }
        else {
            // log as a debug point
            module.exports.debugPoint(MethodDetails, 'Log Timing');
        }
        // return the end time
        return MethodDetails.timing.end_time;
    }
    return null;
};

/**
 * Used to log the methond name, method parameters, and an error generated from the
 * joi validation of an end point.  Log level used is warn.
 * @param {string} method_name - The methos for which the parameters are being logged.
 *                               Format: [file].[method] || [method]
 * @param {object} request - The request object passed to the end point.
 * @param {object} error - The validation error triggered.
 * @return {string} the determined start_time time (ISOString).
 */
var LogValidationError = function (method_name, request, error, correlation_id) {
    // allow these logs to not be written for local debugging
    if (process.env.SUPRESS_TIMING !== 'true') {
        var MethodDetails = module.exports._internalFunctions.getMethodDetailsObject(method_name, 'Input Validation Error');

        // add the relevant request details to the object to log
        if (request) {
            // function for handling pulling out values from the request object
            var pull_detail = function (value) {
                var undefined_object;
                if (value && _.isPlainObject(value) && Object.keys(value).length) {
                    return value;
                }
                return undefined_object;
            };
            MethodDetails.query = pull_detail(request.query);
            MethodDetails.params = pull_detail(request.params);
            MethodDetails.payload = pull_detail(request.payload);
        }
        // add the relevant error details to the object to log
        if (error) {
            error = module.exports._internalFunctions.formatError(error);
            MethodDetails.error = error;
        }
        // allow these logs to be recorded debugPoint logs for local debugging
        if (process.env.TIMING_AS_DEBUGPOINT !== 'true') {
            // log method details object
            module.exports._internalFunctions.logPassthrough('warn', MethodDetails, correlation_id);
        }
        else {
            // log as a debug point
            module.exports.debugPoint(MethodDetails, 'Log Validation Error');
        }
        // return the end time
        return MethodDetails.timing.start_time;
    }
    return null;
};

/**
 * Used to format a straight log call.
 * NOTE: Calls to this method should be replaced with calls to logTiming.
 * @param {string} type - The log level to log.
 * @param {any} detail - Value to log.
 *                       The preferred type for this is an object, but if a non-object
 *                       value is passed it is added to an object to log.
 * @param {string} correlation_id - the correlation id to be logged.
 * @param {string} message_text - Optional.  This is additional text to log with the message.
 * @return No return value.
 */
var Log = function (type, detail, correlation_id, message_text) {
    if (process.env.SUPRESS_LOGGING !== 'true') {
        // if the detail isn't an object OR additional message text is supplied then formatting required
        if (!_.isPlainObject(detail) || message_text) {
            // default object format
            var data_toRecord = {
                'message': '',
                'detail': {}
            };

            // verify we have a detail value
            if (detail !== null && typeof detail !== 'undefined') {
                if (detail.constructor !== {}.constructor) {
                    var key = typeof detail;
                    var value = detail;
                    detail = {};
                    detail[key] = value;
                }

                // if correlation id was pased in, ensure it gets preserved
                if (typeof detail.correlation_id !== 'undefined' && detail.correlation_id !== null) {
                    data_toRecord.correlation_id = detail.correlation_id;
                }

                data_toRecord.detail = detail;
            }

            // add the additional message text values to the object to log
            if (message_text) {
                data_toRecord.message = message_text;
            }

            // send the now formatted detail to the logger
            module.exports._internalFunctions.logPassthrough(type, data_toRecord, correlation_id);
        }
        // only three values passed and the detail is an object`
        else {
            // send to the logger
            module.exports._internalFunctions.logPassthrough(type, detail, correlation_id);
        }

        return true;
    }
    
    return false;
};

/**
 * Used to add a log entry via the logger.  Ensures the correlation_id is of the correct data type
 * @param {string} type - The log level to log.
 * @param {object} detail - Value to log.
 * @param {string} correlation_id - the correlation id to be logged.
 * @return No return value.
 */
var LogPassthrough = function (type, detail, correlation_id) {
    if (!type) {
        type = 'debug';
    }

    // pass information through to the logger ensuring that the correlation id is valid
    logger.get().log(type, detail, module.exports._internalFunctions.validateCorrelationId(correlation_id));
    return;
};

/**
 * Used to write the debug point information to the console.
 * @param {string} header_line - The header line for the debug point message.
 * @param {string} message_line - The body of the debug point message.
 * @param {string} footer_line - The footer line for the debug point message.
 * @param {number} recursive_attempt - Used to support indenting recursive call logs.  Null or 0 means no indent.
 * @return No return value.
 */
var DebugPoint_Output = function (header_line, message_line, footer_line, recursive_attempt) {
    if (process.env.SUPRESS_LOGGING !== 'true') {
        // default values that are not passed
        recursive_attempt = recursive_attempt ? recursive_attempt : 0;
        header_line = header_line || '';
        message_line = message_line || '';
        footer_line = footer_line || '';
        // preceding spaces for recursive calls
        // additional space at the end is to account for the fact that join will be 1 less than the total array size
        var preceding_spaces = Array(recursive_attempt * 3).join(' ') + (recursive_attempt ? ' ' : '');
        // log the first separator line
        console.log(preceding_spaces + header_line);

        // if the value to debug is JSON
        if (message_line.constructor === {}.constructor) {
            // ensure that the entire object gets logged
            console.log(util.inspect(message_line, false, null));
        }
        else {
            // if not JSON, then log it
            console.log(preceding_spaces + message_line);
        }

        // log the second separator line
        console.log(preceding_spaces + footer_line);

        return true;
    }
    return false;
};

/**
 * Used to do a console.log of the debug_message surrounded by a start line and a finish line to help the debug point stand out.
 * @param {string} debug_message - The message to print out.
 * @param {string} header - Additional text to add to the header line.
 * @param {character} separator_line_character - the character to use for the header and footer line.  Default = '-'
 * @param {number} line_length - The length of the header and footer lines.  Default = 81
 * @param {boolean} center_header - true = center the header text.  default = false.
 * @return No return value.
 */
var DebugPoint = function (debug_message, header, separator_line_character, line_length, center_header, recursive_attempt) {
    // allow these logs to not be written for calls from a server
    if (process.env.SUPRESS_DEBUG_POINT === 'false') {
        var current_time = ' ' + moment().format('hh:mm:ss.SSS') + ' ';

        // default line_length if not supplied
        line_length = line_length || 80;

        // set the separator to the default if one not supplied
        separator_line_character = separator_line_character || '-';
        // because of join the line will be one less than the total length, so add a separator_line_character at the end
        var header_line = Array(line_length).join(separator_line_character) + separator_line_character;
        var footer_line = header_line;
        var initial_characters = 3;
        var start_of_line = Array(initial_characters).join(separator_line_character) + current_time + separator_line_character;

        // add the header text to the start of the line
        if (header) {
            // add spacing around the message to allow it to stand out
            header = ' ' + header + ' ';
            // determine spacing required to center the header text
            if (center_header) {
                var spacing_required_to_center = '';
                var length_of_line_after_start = line_length - start_of_line.length;
                if (length_of_line_after_start > header.length) {
                    spacing_required_to_center = Array(Math.trunc((length_of_line_after_start - header.length) / 2) + 1).join(separator_line_character);
                }
                header = spacing_required_to_center + header;
            }

            // because we are showing the time in the header, use a colon to separate the time from the main body
            start_of_line += header;
        }

        // because end_of_line_length is used in the array.join functionality this needs to be one greater than line_length - start_of_line.length
        var end_of_line_length = start_of_line.length < line_length ? line_length - start_of_line.length + 1 : 0;
        // compose the header line
        header_line = start_of_line + Array(end_of_line_length).join(separator_line_character);

        // if the message is null, convert that to a string to prevent errors in the code
        if (typeof debug_message === 'undefined' || debug_message === null) {
            debug_message = 'null';
        }

        module.exports._internalFunctions.debugPoint_Output(header_line, debug_message, footer_line, recursive_attempt);
    }

    return true;
};

module.exports = {
    log: Log,
    logMethodDetail: LogMethodDetail,
    logTiming: LogTiming,
    logValidationError: LogValidationError,
    debugPoint: DebugPoint,
    _internalFunctions: {
        formatError: FormatError,
        getMethodDetailsObject: GetMethodDetailsObject,
        debugPoint_Output: DebugPoint_Output,
        validateCorrelationId: ValidateCorrelationId,
        logPassthrough: LogPassthrough
    }
};
