'use strict';

// Object can not be modified on it's own so a local copy must be used
var extend = Object;

extend.getPropertyByPath = function (obj, propertyPath) {
    if (!obj) {
        return obj;
    }
    // split up the property paths
    propertyPath = propertyPath.replace(/\[(\w+)\]/g, '.$1').replace(/^\./, '');
    var tree = propertyPath.split('.');
    // get the last property key
    var leaf = tree.pop();
    // while we have some keys left and the object[key] exists, keep on trucking
    if (tree.length) {
        var i = 1;
        var key = tree[0];
        while ((obj = obj[key]) && i < tree.length) {
            key = tree[i];
            i++;
        }
    }
    // if we still got an object return the value or nothing
    if (obj) {
        return obj[leaf];
    }
};

// DO NOT USE FOR TRI VALUES
// If you want to accept certain falsy types pass in as an array
// e.g. Object.compact({}, [0,'',false,null]);
extend.compact = function (obj, allowed) {
    var self = this;
    allowed = allowed || [];

    function compactArray(array) {
        return array.filter(function (value) {
            if (value) {
                return true;
            }
            if (allowed.indexOf(value) > -1) {
                return true;
            }
            return false;
        });
    }

    if (Array.isArray(obj)) {
        obj = compactArray(obj);
    }
    for (var key in obj) {
        if (typeof obj[key] == 'object') {
            if (Array.isArray(obj[key])) {
                obj[key] = compactArray(obj[key]);
            }
            self.compact(obj[key], allowed);
        }
        if (!obj[key] && allowed.indexOf(obj[key]) < 0) {
            delete obj[key];
        }
    }
    if (obj) {
        return obj;
    }
};

/**
 * Copies a property and value from the source object to the target object, given a path from the source object.
 * @param target the target object to receive the property
 * @param targetProperty the target property name of the property to add to target
 * @param source the source object
 * @param sourcePath the property path in the source object
 * @param includeNull if property path is invalid, set target property to null (true) or leave it out (false)
 * @param transformFunction function to transform the value of the property before adding to the target
 * @returns {boolean} true if the property was added to the target object
 */
extend.copyProp = function(target, targetProperty, source, sourcePath, includeNull, transformFunction) {
    if (Object.prototype.toString.call(includeNull) === '[object Function]') {
        transformFunction = includeNull;
        includeNull = false;
    }
    includeNull = includeNull || false;
    try {
        var value = sourcePath.split('.').reduce(function(prev, curr) {
            return prev ? prev[curr] : null;
        }, source || self);
        if (value) {
            if (transformFunction) {
                target[targetProperty] = transformFunction(value);
            } else {
                target[targetProperty] = value;
            }
            return true;
        }
        if (includeNull) {
            target[targetProperty] = null;
            return true;
        }
    } catch(err) {
        //ignore err
    }
    return false;
};